React native can be used with both iOS and android.
Advantages:  cross-platform compatibility, native components, hot reloading(changes in real time), strong community
Support,  easy to learn.

Expo is basically like create-react-app, or vite. It provides tools and services that simplify the development process.
You don’t have to worry about configuring your dev environment or native dependencies.

<Text></Text> is used instead of p and h tags.
<View></View> is used instead of divs. It uses flex box by default.
TouchableOpacity component. A button that fades when interacted with.
ActivityIndicator. Spinner or loading indicator in app.
Flatlist. Like map in react. It renders a long list of components to be scrolled efficiently. Larger lists, use Flatlist.
Scrollview. A box that holds things and allows scrolling.
SafeAreaView. Safe zone to render content where on any device it can be viewed. Won’t be blocked by home button or something.



Let’s create an app! 
THE SETUP
1. Make a folder in desktop and drag it into vs code.
2. Open up the docs for expo.github.io/router/docs.
3. Type npx create-expo-app@latest -e with-router ./ (the ./ is for having this in the folder we are in) inside the terminal of vs code.
4. Run npm install.
5. Create a folder called app with the files index.js and _layout.js
6. In _layout.js, we import Stack from react-native and make an arrow function called Home. Export default function.
7. In index.js we import View and Text from react-native and return Text wrapped in View. Export default function.
8. We need more dependencies. In the terminal type npm install expo-font axios react-native-dotenv
  - expo-font is to add a custom font
  - axios is for API requests
  - react-native-dotenv is an external package to allow us to work with environment variables.
9. Type npm start.
10. From here, there is a mobile app called Expo Go to download. We can scan the QR code given and test our app!
11. If we cannot start the app because of wifi, here are the steps to fix that....
11a. Ctrl+C in the terminal to stop the app.
11b. Type sudo npm install -g expo-cli. This installs the global expo cli package to run the application on.
11c. Then type expo-cli start --tunnel.
12. This doesn't work. Type npx expo-doctor
13. Then type npx expo install --check to see what's wrong.
14. Then the terminal will fix your dependencies for you.
15. Then type npx expo start
16. Still didn't work.
17. Type sudo npm install --global @expo/ngrok@^4.1.0
18. Type npm install uuid@latest
19. Make sure in package.json it says expo start --tunnel
20. Run npm run start

None of this works. I'm going to emulate an iOS app from my computer instead. I'll try this out on my
wifi at home I guess. I downloaded XCode

I finally got the app to display in a phone.

I had to download assets, components, constants, and styles from the github repository from the tutorial.
The styles will be provided, but not the logic. 

Let's start.

---

1. We go into app/index.js and add...
Stack and useRouter from expo-router
useState from react
View, Scrollview, and SafeAreaView from react native.

2. Define a router and wrap everything in a SafeAreaView tag.
So within the home function:
  const Home = useRouter();

Then we have a self closing <Stack.Screen /> wrapped in a <SafeAreaView></SafeAreaView> tag.

2a. Let's give some styles to SafeAreaView. It's just an attribute of style within the first tag.
style={{ flex: 1, backgroundColor: ---}}

3. Within Stack.Screen, we give it an attribute of options. Options is written like
options={{}}. First, we tackle some header settings.

3a. headerStyle: { backgroundColor: ---}. Changes color of the header. We can import
an object from a different folder with a bunch of preselected color schemes.

3b. headerShadowVisible: true/false. Just shows an underline underneath the header or not.

3c. headerLeft: () => (). This object key takes a component within an arrow function. In our app,
we put in a component called ScreenHeaderBtn. It seems headerLeft is just something that renders
to the left of the header.

3d. headerRight: () => (). Same deal. Something that renders to the right of the header.

3e. headerTitle: "". Gets rid of the "index" that is in the header by default. Or, you can name
it something else.

4. Now that we've done some work to the header, let's work on the body, and make it scrollable.
Add a <ScrollView></ScrollView> tag underneath the <Stack.Screen /> tag. Set an attribute of
showsVerticalScrollIndicator={false}. Users should know to scroll.

4a. Let's add a <View></View> tag within the ScrollView. This View tag shall have some styles,
like flex: 1, and padding: SIZES.medium. Having objects imported to refer to in styling helps a lot.

4b. Within the <View></View> tag, we'll have some components called Welcome, popularjobs,
and nearbyjobs in there.

5. Let's work a little on the header now. There are going to be buttons in the header
on either side. Inside a ScreenHeaderBtn component, we import TouchableOpacity and Image from
react-native. Then we import styles from that folder, and we import React from 'react'.
Then in a ScreenHeaderBtn arrow function, we return an <Image /> tag wrapped
inside of a <TouchableOpacity></TouchableOpacity> tag. This image tag will have a source that we
take through a prop. Inside headerLeft and headerRight in app/index.js, we've called this component. We should have
a iconUrl prop to pass through. The styling properties given to the image can be found within the stylesheet.js
page. There some complicated stuff in there, but basically it has CSS within a JS object that we can call
inside curly brackets in style={}.

5a. We also give the TouchableOpacity tag a style too.
style={styles.btnContainer}. These are weird styles because they are premade already in a js file.

5b. The TouchableOpacity also takes a function once its pressed. So we give it an onPress attribute that takes
a handlePress prop. We won't pass in this prop until later.

5c. headerLeft displays a hamburger menu, and headerRight will display a profile picture. The iconUrl in
headerRight will have a different image.

6. I think header stuff is cool for now. Let's focus on the Welcome component. Within the welcome component code,
let's import useState from 'react', useRouter from 'expo-router', 
styles from the js stylesheet that should be in the same folder, icons and SIZES from
the constants folder, and a couple of
things from 'react-native':
View (div)
Text (p)
TextInput (input)
TouchableOpacity
Image
Flatlist.

6a. Let's define our router within the Welcome arrow function.
const router = useRouter();

**FOR THE RECORD, I think this person made these js files for all the stylings 
AFTER fiddling around with having the styles done inline. It's kinda crazy to be doing
these styles like this.

6b. Let's go into the return statment and wrap a view inside a view. The inner view has
a width of 100%. Inside the inner view is a text element that says Hello Nick. To this text
element we give it a styling of a font, 20px sizing, and a blackish color.

6c. Let's have another Text element with a message like "Find your perfect job"
with a bold styling, 24px sizing, slightly different color, and margin top of 2.

6d. Let's have a separate view within another view. Inside all this will be a text input. The outer div
is to have flex-direction row and text centering, and margining. The inner div is to change the backgroundColor
and border radius.

6e. We can do a custom font for the text input. Go into _layout.js and import useCallback from react,
useFonts from expo-font, and " import * as SplashScreen from 'expo-splash-screen' ". This last thing
allows a splash screen to remain on the page until everything loads in. Don't forget to have
SplashScreen.preventAutoHideAsync() outside of the Layout arrow function so that it can run
primarily.

6f. Now, within the layout arrow function, we load our fonts with the useFonts function (look to _layout.js)
for this syntax. After this, we make a conditional statment that only when the fonts are loaded, we show the
homescreen. This is with the useCallback function we imported, that acts as a useEffect type thing. In the
dependencies array, we put the fonts.

  const [fontsLoaded] = useFonts({
    DMBold: require("../assets/fonts/DMSans-Bold.ttf"),
    DMMedium: require("../assets/fonts/DMSans-Medium.ttf"),
    DMRegular: require("../assets/fonts/DMSans-Regular.ttf")
  })

  const onLayoutRootView = useCallback(async () => {
    if(fontsLoaded) {
      await SplashScreen.hideAsync();
    }
  }, [fontsLoaded])

6g. Then we add this inside the overall arrow function:
  if(!fontsLoaded) return null

  return <Stack onLayout={onLayoutRootView}/>;
We do all this to ensure that our fonts load where we choose them to.

6h. Now we add attributes to the TextInput.
value =""   what text is in the bar at any moment (we will assign a state variable to this.)
onChange={() => {}}   a function to run once the bar changes (text is put in)
placeholder=""  what the bar says without text in in

7. Let's put a search button next to the search bar. This is putting an Image inside a 
TouchableOpacity within the View that is flex-dir row that holds the search bar, and now this
button. We give the image and the button some good styling. The image resizeMode attribute should
be set to "contain". We add an empty callback function to the TouchableOpacity that we will fill in
later. onPress={() => {}}

8. Next, we'll have a Flatlist tag inside a view tag underneath the view container for the search bar
and search button. The flatlist will display 3 different types of data, which we will declare on top.

8a. We make a variable that stores different job types above the welcome arrow function. We then pass
this into the flatlist tag with an attribute of data={jobTypes}

8b. Now we need to render each jobType. Within a renderItem attribute, we destructure each item into
a button card with text in it.

8c. Now we can add styling to the button border with a useState variable. Let's make a useState variable
inside the total arrow function that stores whether a button has been clicked or not. We save this
variable equal to the String value of the button itself. So within the styling of each button
we map to the page, we set the border color equal to a boolean value of whether or not our state variable
equals a button text. We can get the state variable to equal the button text by clicking a certain button.
**IMPORTANT TRICK

8d. Also within the onPress of a button, we want to route the user to the search page of that type of job.
This is done with router.push(``), where a template string with the specific job is put in.

8e. Along with the border styling to be active when a job is selected, we can have the text of all the non-clicked
buttons be faded. This is done with the same trick: a boolean value for the font color of everything.

8f. Within FlatList, you need to add an additional props besides data and renderItem. keyExtractor grabs
a unique key for each item.
keyExtractor={item => item}
Also, having 
            contentContainerStyle={{columnGap: SIZES.small}}
            horizontal

gives the options a bubble type appearance in the app.

Now that some of the UI is done, we are going to utilize an API call within popular jobs to show
popular jobs.

9. Let's get our imports situated within popular jobs.
import { useState } from 'react'
import { View, Text, TouchableOpacity, FlatList, ActivityIndicator  } from 'react-native' (we have a new thing called ActivityIndicator here)
import { useRouter } from 'expo-router'

import styles from "./popularjobs.style";
import { COLORS, SIZES } from '../../../constants'
import PopularJobCard from '../../common/cards/popular/PopularJobCard' (we are gonna use a card to populate things.)


9a. Inside the popular jobs arrow function, we define our router
const router = useRouter();

9b. Now its time to focus on the return statement. Let's have an overall view as the container. Then,
a header View inside that with a text element saying Popular jobs, and a button element saying show all.

9c. Now that the header view is done, let's have a cardcontainer view underneath. Within this view,
we wanna show a loading icon while the we are fetching data. So, we must....

9ca. Create a variable in the total arrow function called isLoading to start.
const isLoading = false;

Now, we create a conditional statement. If we are loading, we display a <ActivityIndicator />. If not,
then we check if we have an error. If so, display some error text. If no error, then we can display our
Flatlist.
        {isLoading ? (
          <ActivityIndicator size='large' colors={COLORS.primary} />
        ) : error ? (
          <Text>Something went wrong...</Text>
        ) : <FlatList
        
        /> }

9d. In our flatlist, we can put mock data, like an array of 1,2,3,4, and render each item
to a PopularJobCard where we display the data. This is just for starters. I've shown how to do this
before above in number 8.

**By the way, flex boxes default to flex-direction: column instead of row.

9e. Then we add our keyExtractor which will be item => item?.job_id once we actually import
data from the API.

9f. We want to do the contentContainerStyle and horizontal stuff like before here:
          contentContainerStyle={ {columnGap: SIZES.medium} }
          horizontal

We are going to eventually make the cards look a lot better, but lets get into API fetching.

10. Create a folder called hooks, and a file in there called useFetch.js

10a. Let's get our imports down pat.
import { useState, useEffect } from 'react'
import axios from 'axios'

10b. Then, create the useFetch arrow function with useState variables inside of..
data set equal to an emptyarray
isLoading set equal to false
error set equal to null
Then export default useFetch at the bottom.
** we are creating these to initialize them.

10c. Now we go back to rapidAPI, get our key and the endpoint, and make
a call to the API to fetch data for the developer jobs. Once we subscribe to a basic
plan, we can find our API 'JSearch', and have our target be Node.js and our client be
Axios when we test a search endpoint.

10d. Let's paste in our options object. We want to alter the url to have template strings
and take a variable, so that we can change our endpoint like such...

const useFetch = (endpoint) => {

 const [data, setData] = useState([]);
 const [isloading, setIsLoading] = useState(false);
 const [error, setError] = useState(null);

 const options = {
  method: 'GET',
  url: `https://jsearch.p.rapidapi.com/${endpoint}`,
  params: {
    query: 'Node.js developer in New-York,USA',
    page: '1',
    num_pages: '1',
    date_posted: 'all'
  },
  headers: {
    'x-rapidapi-key': rapidApiKey,
    'x-rapidapi-host': 'jsearch.p.rapidapi.com'
  }
};

}

You should notice that the key given in headers is not visible. We need to set up our key in a .env file.
Make sure the .env file is in the root directory.

We set up something like...
RAPID_API_KEY = thekey

Then we import it into useFetch.js...
import { RAPID_API_KEY } from '@env'
then
const rapidApiKey = RAPID_API_KEY

**The env file stuff wasn't working, so we used the code straight up in the file, oh well.

Now we can use this variable.

10e. Instead of the params being static like they are above, we can pass a variable to them.

params: { ...query } (with query being a parameter in the useFetch arrow function).


10f. Let's have an async fetchData function at the bottom. Here, we will setIsLoading(true) and use
a try, catch, finally structure. Try to await the axios.request(options), catch errors, finally set loading
as false.
 const fetchData = async () => {
  setIsLoading(true);

  try {
    const response = await axios.request(options)
    setData(response.data.data)
    setIsLoading(false);
  } catch (error) {
    setError(error)
    alert("There is an error")
  } finally {
    setIsLoading(false)
  }
 }

10g. Have a useEffect at the bottom of the main arrow function where we run this fetchdata function. No
dependencies in the array. There can be a refetch arrow function after this just for debugging.

10h. Then from this overall useFetch arrow function, we return the state variables and the refetch
function.

11. Let's import this file into the Popular jobs component now. This means we can erase the isLoading
and the error variables that we had. We can destructure the return variables from useFetch inside of the
PopularJobs arrow function in the beginning.

11a. useFetch takes two arguments so the first one is 'search', because that's our endpoint, and
the query shall be anything, but inside of an object. This is because we use the spread operator
in useFetch, so we will spread out the key and values we pass in. Like this in the popjobs arrow function:
  const { data, isLoading, error, refetch } = useFetch
  ('search', {
    query: 'React developer',
    num_pages: 1
  })

This does it for loading in from the API.

12. Let's make the PopularJobCards render into the page. Let's get our imports
right:
import { View, Text, TouchableOpacity, Image } from 'react-native'

12a. We want to return a button for every card. It seems the structure will be a button container.
Inside the button will be an image wrapped in another button, and a text box. There is a lot to note about the styling
of these buttons and items. Mostly about having state variables equal to ones that you choose. We will
discuss this later, after the UI is made.

12b. Notably, the text element has an attribute of numberOfLines={1}. This is so that whatever is in the
text appears on one line.

12c. Inside of the overall button, and next to the inside button and text element, let's add a view. This
view will display a text element with the job title.

12d. Next, we can put another text element in that view that displays the job location.

12e. Some of the companies don't have logos, so we need to make a utility function to check for this. Let's name
create a folder called utils with a file called index.js. If there isn't a company logo, then there is a null value.
We make a export const arrow function that returns a boolean true if the url is not null, and a boolean false
if the url is null. We import this function into our Job card component. Within the source curly brackets,
we use a ternary operator by first calling the arrow function we imported. If its true, have the source
equal to the logo, and if false, have a https image that can default load in. Here's the arrow function:
export const checkImageUrl = (url) => {
  if(url !== null){
    return true
  } else {
    return false
  }
}

Here's the import statement in job card:
import { checkImageUrl } from '../../../../utils';

And here's the logic of ternary:
        <Image 
          source={{ uri: checkImageUrl(item.employer_logo)
          ? item.employer_logo : "random https image"}}
        />

Bow bow.

In the video, instead of utilizing null values, the guy found some function to check the url that returns
true or false. Here's the timestamp for that and the video url.
<timestamp 1:11:34? url: https://www.youtube.com/watch?v=mJ3bGvy0WAY&t=3702s





13. Let's work on the UI of the nearby jobs component. We already made the useFetch function, so
calling data should be easy. Instead of starting fresh, we can copy and paste our popular jobs component
to this. I'm definetly seeing code that is being duplicated that could easily be components, but I'll let
it slide for now and come back to that later.

13a. Things we are changing about nearbyjobs:
We don't need a flatlist import
We don't need a useState import
Change the styling and NearbyJobCard import paths
We only need COLORS from constants.
Change the main arrow function and the export default names to nearby.
Change some text in the header to nearby.
Instead of a flatlist, we do a map function.

13b. We want to map a NearbyJobCard for every data point. The NearbyJobCard takes
the props of job, key (to have unique cards), and handleNavigate (to redirect the page upon clicking.)
The key is a template string with `nearby-job-${job?.job_id} for a unique key.
Don't worry about the router.push() stuff, because the page routing section of this tutorial will go
over what exactly goes in that box.
The this card is going to be the same as a popular card. Check nearbycard for differences.
The nearby jobs hold the same information as the popular cards.


** We still haven't solved the selectedJobs variable within the PopularJobs component.


14. Let's work on the job details page. Go into the app folder and make a new folder called job-details.
Here, make a file called [id].js. We can type 'rafce' to instantly make an arrow function. We are going
to import the following:
import { useCallback, useState } from 'react'
import { Text, View, SafeAreaView, ScrollView, ActivityIndicator, RefreshControl } from 'react-native';
import { Stack, useRouter, useSearchParams } from 'expo-router'

RefreshControl is a new thing we will be dealing with.

We will also be importing a few components, some styles, and the useFetch hook function.
Here are the components we are importing:
Company
JobAbout
JobFooter
JobTabs
ScreenHeaderBtn
Specifics

